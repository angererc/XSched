.include "basedir.include"

### Domains
.include "Object.dom"
.include "Field.dom"
.include "Method.dom"
.include "Variable.dom"

#9.802
.bddvarorder Method0_Method1_Variable0_Variable1_Object0_Object1_Object2_Object3_Object4_Object6_Object7_Object8_Field0_Field1_Object9_Object5


#statements     		                                                            
monitorEnter			(m:Method, variable:Variable) 							input
new						(m:Method, dest:Variable, obj:Object)					input
constant				(m:Method, variable:Variable, object:Object)			input
load					(m:Method, variable:Variable, base:Variable, field:Field)	input
primLoad				(m:Method, base:Variable, field:Field)					input
staticLoad				(m:Method, dest:Variable, field:Field) 					input
staticPrimLoad			(m:Method, field:Field) 								input
store					(m:Method, base:Variable, field:Field, source:Variable) input
primStore				(m:Method, base:Variable, field:Field) 					input
staticStore				(m:Method, field:Field, source:Variable) 				input	
staticPrimStore			(m:Method, field:Field) 								input	

executionContext		(nowCtxt:Object, now:Object, \
							 thisCtxt:Object, this:Object, \
							 m:Method)											input

heapPT					(baseCtxt:Object, base:Object, \
							 field:Field, \
							 targetCtxt:Object, target:Object)					input
							
variablePT				(nowCtxt:Object, now:Object, \
						 thisCtxt:Object, this:Object, \
						 method:Method, variable:Variable, \
						 actContext:Object, object:Object)						input	
						
parallel(nowCtxt1:Object, now1:Object, nowCtxt2:Object, now2:Object) input

#what statements in a method count as access
access(method:Method, variable:Variable)
access(m, v) :- monitorEnter(m, v).
access(m, v) :- new(m, v, _).
#access(m, v) :- constant(m, v, _).
access(m, v) :- load(m, _, v, _).
access(m, v) :- primLoad(m, v, _).
access(m, v) :- store(m, v, _, _).
access(m, v) :- primStore(m, v, _).

accessStatic(method:Method, field:Field)
accessStatic(m, f) :- staticLoad(m,_, f).
accessStatic(m, f) :- staticPrimLoad(m, f).
accessStatic(m, f) :- staticStore(m, f, _).
accessStatic(m, f) :- staticPrimStore(m, f).

methodMayAccess(nowCtxt:Object, now:Object, m:Method, objCtxt:Object, obj:Object)
methodMayAccess(nowCtxt, now, m, objCtxt, obj) :- \
	executionContext(nowCtxt, now, thisCtxt, this, m), \
	access(m, v), \
	variablePT(nowCtxt, now, thisCtxt, this, m, v, objCtxt, obj).
methodMayAccess(nowCtxt, now, m, objCtxt, obj) :- \
	executionContext(nowCtxt, now, _, _, m), \
	accessStatic(m, f), \
	heapPT(0, 0, f, objCtxt, obj).
	
parallelMethods(m:Method) outputtuples printsize
parallelMethods(m) :- \
	parallel(nowCtxt1, now1, nowCtxt2, now2), \
	methodMayAccess(nowCtxt1, now1, m, objCtxt, obj), \
	methodMayAccess(nowCtxt2, now2, _, objCtxt, obj).