.basedir "dataset"

### Domains
	.include "Bytecode.dom"
	.include "Variable.dom"
	.include "Object.dom"
	.include "Field.dom"
	.include "Type.dom"
	.include "Selector.dom"
	.include "Method.dom"
	.include "ParamPosition.dom"
	
### Relations
	newStatement	(variable:Variable, object:Object)							input
	store			(bc:Bytecode, base:Variable, field:Field, source:Variable) 	input
	load			(bc:Bytecode, base:Variable, field:Field, dest:Variable) 	input
	assign0			(dest:Variable, source:Variable)							input
	
	variableType	(variable:Variable, type:Type)								input
	objectType		(object:Object, type:Type)									input
	assignable		(supertype:Type, subtype:Type)								input
	
	methodImplementation	(type:Type, name:Selector, target:Method)			input
	actual			(invokeBC:Bytecode, param:ParamPosition, var:Variable)		input
	formal			(method:Method, param:ParamPosition, var:Variable)			input
	methodReturn	(method:Method, var:Variable)								input
	callSiteReturn	(invokeBC:Bytecode, var:Variable)							input
	staticInvoke	(invokeBC:Bytecode, target:Method)							input
	methodInvoke	(method:Method, invokeBC:Bytecode, name:Selector) 			input
	
	canPointTo		(variable:Variable, object:Object)
	assign			(dest:Variable, source:Variable)
	
	variablePT		(variable:Variable, object:Object)				outputtuples
	heapPT			(base:Object, field:Field, target:Object)		outputtuples
	invocationEdge	(invokeBC:Bytecode, target:Method)				outputtuples
	
### Rules

	canPointTo(v, obj) :- variableType(v, varType), objectType(obj, objectType), assignable(varType, objType).
	
	variablePT(v, obj)	:- newStatement(v, obj).
	variablePT(v1, obj)	:- assign(v1, v2), variablePT(v2, obj), canPointTo(v1, obj).
	variablePT(v2, obj2):- load(_, v1, f, v2), variablePT(v1, obj1), heapPT(obj1, f, obj2), canPointTo(v2, h2).
	
	heapPT(obj1, f, obj2):- store(_, v1, f, v2), variablePT(v1, obj1), variablePT(v2, obj2).
	
	invocationEdge(invokeBC, m) :- staticInvoke(invokeBC, m).
	#actual 0 = now, actual 1 = this, actual 2 = 1st parameter, ...
	invocationEdge(invokeBC, m2) :- methodInvoke(m1, invokeBC, n), actual(invokeBC, 1, v), variablePT(v, obj), objectType(obj, t), methodImplementation(t, n, m2).
							
	assign(v1, v2) :- assign0(v1, v2).
	assign(v1, v2) :- invocationEdge(invokeBC, m), formal(m, z, v1), actual(invokeBC, z, v2).
	assign(v1, v2) :- invocationEdge(invokeBC, m), methodReturn(m, v1), callSiteReturn(invokeBC, b2).
	