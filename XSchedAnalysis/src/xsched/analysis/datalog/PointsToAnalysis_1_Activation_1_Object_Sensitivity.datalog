# Activation-sensitive and 1-object-sensitive points to analysis
# objects in the heap are distinguished by the activation they were created in
# variables are distinguished by the now activation and the current this

.basedir "dataset"

### Domains
	.include "BC.dom"
	.include "Variable.dom"
	.include "Field.dom"
	.include "Type.dom"
	.include "Selector.dom"
	.include "Method.dom"
	.include "ParamPosition.dom"
	
### Relations
	roots					(method:Method)											input
	                		                                                            
	#statements     		                                                            
	new						(bc:BC, variable:Variable)								input
	schedule				(bc:BC, dest:Variable)									input
	now						(bc:BC, variable:Variable)								input
	store					(bc:BC, base:Variable, field:Field, source:Variable) 	input
	load					(bc:BC, base:Variable, field:Field, dest:Variable) 		input
	phi						(bc:BC, dest:Variable, source:Variable)					input
	                		                                                            
	#types          		                                                            
	variableType			(variable:Variable, type:Type)							input
	objectType				(object:BC, type:Type)									input
	assignable				(supertype:Type, subtype:Type)							input
	                                                                                   
	#control flow                                                                       
	member					(type:Type, name:Selector, target:Method)				input
	actual					(invokeBC:BC, param:ParamPosition, var:Variable)		input
	formal					(method:Method, param:ParamPosition, var:Variable)		input
	methodReturn			(method:Method, var:Variable)							input
	                                                                                    
	#call sites                                                                         
	staticClassInvoke		(invokeBC:BC, target:Method)							input
	staticInstanceInvoke	(invokeBC:BC, target:Method)							input
	virtualInvoke			(invokeBC:BC, name:Selector) 							input
	callSiteReturn			(invokeBC:BC, var:Variable)								input
	                                                                                    
	inlinedActivationScope	(method:Method, schedBC:BC, bc:BC)						input
	methodActivationScope	(method:Method, bc:BC)									input

	## bc is executed in variable scope {methodNow, this} but invokes use scope bcNow
	executionContext		(methodNowCtxt:BC, methodNow:BC, thisCtxt:BC, this:BC, bc:BC, bcNowCtxt:BC, bcNow:BC)
	canPointTo				(variable:Variable, object:BC)
	
	variablePT				(nowCtxt:BC, now:BC, thisCtxt:BC, this:BC, variable:Variable, \
							 actContext:BC, object:BC)								output
							
	heapPT					(actContext1:BC, base:BC, \
							 field:Field, \
							 actContext2:BC, target:BC)								output
							
	invocationEdge			(nowCtxt:BC, now:BC, thisCtxt:BC, this:BC, invokeBC:BC, \
							 receiverCtxt:BC, receiver:BC, target:Method)			output
	
### Rules
	#known objects:
	#bc 0: the global object (receiver of static class methods)
	
	#**********************
	#Root
	#**********************
	invocationEdge(0, 0, 0, 0, 0, 0, 0, rootMethod) :- \
							roots(m).
	
	#**********************
	#type filtering
	#**********************
	canPointTo(v, obj) :- \
							variableType(v, varType), \
							objectType(obj, objectType), \
							assignable(varType, objType).
	
	#**********************
	#execution scope
	#**********************
	# for an inlined schedule: the current methodNow is the creation context
	executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, alsoMethodNow, schedBC) :- \
							invocationEdge(methodNowCtxt, methodNow, _, _, _, thisCtxt, this, m), \
							inlinedActivationScope(m, schedBC, bc) \
							methodNow=alsoMethodNow.
													
	executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, methodNowCtxt, alsoMethodNow) :- \	
							invocationEdge(methodNowCtxt, methodNow, _, _, _, thisCtxt, this, m), \
							methodActivationScope(m, bc), \
							methodNow=alsoMethodNow.
	
	#**********************
	#new statements
	#**********************
	# do not collapse the new objects for multiple callers (use alsoMethodNow instead of bcNow)
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, v, alsoMethodNow, bc)	:- 	\
							new(bc, v), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, _, _), \
							methodNow=alsoMethodNow.
	
	#**********************
	#schedule statement
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, v, alsoMethodNow, bc) :- \
							schedule(bc, v), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, _, _), \
							methodNow=alsoMethodNow.
	
	#**********************
	#now statement
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, v, bcNowCtxt, bcNow) :- \
							now(bc, v), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, bcNowCtxt, bcNow).
	
	#**********************
	#phi-node assignments; could remove executionContext-clause?
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, v1, actCtxt, obj)	:- \
							phi(bc, v1, v2), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, _, _), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, v2, actCtxt, obj), \
							canPointTo(v1, obj).
	
	#**********************
	#loads; could remove executionContext-clause?
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, v2, actCtxt, obj2):- \
							load(bc, v1, f, v2), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, _, _), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, v1, someActCtxt, obj1), \
							heapPT(someActCtxt, obj1, f, actCtxt, obj2), \
							canPointTo(v2, obj2).
	
	#**********************
	#stores; could remove executionContext-clause?
	#**********************
	heapPT(actCtxt1, obj1, f, actCtxt2, obj2):- \
							store(bc, v1, f, v2), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, bc, _, _), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, v1, actCtxt1, obj1), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, v2, actCtxt2, obj2).
	
	#**********************
	#static calls
	#**********************
	#statically bound instance methods
	invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, invokeBC, receiverCtxt, receiver, m) :- \
							staticInstanceInvoke(invokeBC, m), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, invokeBC, bcNowCtxt, bcNow), \
							actual(invokeBC, 0, recVar), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, recVar, receiverCtxt, receiver).
	
	#statically bound class methods (doesn't use actual 0 variable but the global object)
	invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, invokeBC, 0, 0, m) :- \
							staticInvoke(invokeBC, m), \
							executionContext(_, _, thisCtxt, this, invokeBC, bcNowCtxt, bcNow).
																													
	#**********************
	#virtual calls
	#**********************
	invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, invokeBC, receiverCtxt, receiver, m) :- \
							virtualInvoke(invokeBC, selector), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, invokeBC, bcNowCtxt, bcNow), \
							actual(invokeBC, 0, recVar), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, recVar, receiverCtxt, receiver), \
							objectType(receiver, t), \
							member(t, selector, m).

	#**********************
	#parameter passing
	#**********************
	variablePT(bcNowCtxt, bcNow, receiverCtxt, receiver, formalVar, objCtxt, obj) :- \
							formal(m, z, formalVar), \															
							invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, invokeBC, receiverCtxt, receiver, m), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, invokeBC, bcNowCtxt, bcNow), \
							actual(invokeBC, z, actualVar), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, actualVar, objCtxt, obj).
						
	#**********************	
	#returns and exceptions
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, callerRetVar, objCtxt, obj) :- \
							callSiteReturn(invokeBC, callerRetVar), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, invokeBC, bcNowCtxt, bcNow), \
							invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, invokeBC, receiverCtxt, receiver, m),  \
							methodReturn(m, retVar), \
							variablePT(bcNowCtxt, bcNow, receiverCtxt, receiver, retVar, objCtxt, obj), \
							canPointTo(callerRetVar, obj).
	