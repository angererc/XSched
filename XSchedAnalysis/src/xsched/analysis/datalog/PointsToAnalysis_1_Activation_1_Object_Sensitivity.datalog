# Activation-sensitive and 1-object-sensitive points to analysis
# objects in the heap are distinguished by the activation they were created in
# variables are distinguished by the now activation and the current this

.basedir "dataset"

### Domains

	.include "BC.dom"
	.include "Object.dom"
	
	.include "Variable.dom"
	.include "ParamPosition.dom"
	
	.include "Type.dom"
	.include "Field.dom"
	.include "Selector.dom"
	.include "Method.dom"
	
	
### Relations
	roots					(method:Method)											input
	                		                                                            
	#statements     		                                                            
	new						(m:Method, bc:BC, dest:Variable, obj:Object)			input
	schedule				(m:Method, bc:BC, dest:Variable, obj:Object)			input
	now						(m:Method, bc:BC, variable:Variable)					input
	constant				(m:Method, variable:Variable, object:Object)		input
	load					(m:M	:Variable, base:Variable, field:Field) 		input
	staticLoad				(m:Method, bc:BC, dest:Variable, field:Field) 			input
	store					(m:Method, bc:BC, base:Variable, field:Field, source:Variable) 	input
	staticStore				(m:Method, bc:BC, field:Field, source:Variable) 		input	
	assign					(m:Method, bc:BC, dest:Variable, source:Variable)		input
	methodReturn			(m:Method, bc:BC, var:Variable)							input
	 		                                                            
	#types          		                                                            
	variableType			(method:Method, variable:Variable, type:Type)			input
	objectType				(object:Object, type:Type)								input
	assignable				(supertype:Type, subtype:Type)							input
	member					(type:Type, name:Selector, target:Method)				input
		                                                                                   
	#control flow                                                                       
	actual					(method:Method, invokeBC:BC, param:ParamPosition, var:Variable)		input
	formal					(method:Method, param:ParamPosition, var:Variable)		input
		
	#activation scopes
	# each bytecode is in one or more (when control flow joins) of the three scopes
	methodActivationScope	(method:Method, bc:BC)									input
	inlinedActivationScope	(method:Method, activation:Object, bc:BC)				input
		# in method, bc is executed in the scope that the callBC returned
	returnActivationScope	(method:Method, bc:BC, callBC:BC)						input 
		                                                                                    
	#call sites                                                                         
	staticClassInvoke		(m:Method, invokeBC:BC, target:Method)					input
	staticInstanceInvoke	(m:Method, invokeBC:BC, target:Method)					input
	virtualInvoke			(m:Method, invokeBC:BC, name:Selector) 					input
	callSiteReturn			(method:Method, invokeBC:BC, var:Variable)				input
	
	## bc is executed in variable scope {methodNow, this} but invokes use scope bcNow
	executionContext		(methodNowCtxt:Object, methodNow:Object, \
							 thisCtxt:Object, this:Object, \
							 m:Method, bc:BC, \
							bcNowCtxt:Object, bcNow:Object)
							
	canPointTo				(method:Method, variable:Variable, object:Object)
	
	variablePT				(nowCtxt:Object, now:Object, \
							 thisCtxt:Object, this:Object, \
							 method:Method, variable:Variable, \
							 actContext:Object, object:Object)						output
							
	heapPT					(actContext1:Object, base:Object, \
							 field:Field, \
							 actContext2:Object, target:Object)						output
							
	invocationEdge			(nowCtxt:Object, now:Object, \
							 thisCtxt:Object, this:Object, \
							 caller:Method, invokeBC:BC, \
							 receiverCtxt:Object, receiver:Object, target:Method)	output
	
### Rules
	#known objects:
	#bc 0: the global object (receiver of static class methods)
	
	#**********************
	#Root
	#**********************
	invocationEdge(0, 0, 0, 0, 0, 0, 0, 0, rootMethod) :- \
							roots(m).
	
	#**********************
	#type filtering
	#**********************
	canPointTo(m, v, obj) :- \
							variableType(m, v, varType), \
							objectType(obj, objectType), \
							assignable(varType, objType).
	
	#**********************
	#execution scope
	#**********************
	# for an inlined schedule: the current methodNow is the creation context
	executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, alsoMethodNow, actObj) :- \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, callBC, callNowCtxt, callNow), \
							invocationEdge(callNowCtxt, callNow, _, _, _, _, thisCtxt, this, m), \
							inlinedActivationScope(m, actObj, bc) \
							methodNow=alsoMethodNow.
													
	executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, methodNowCtxt, alsoMethodNow) :- \	
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, callBC, callNowCtxt, callNow), \
							invocationEdge(callNowCtxt, callNow, _, _, _, _, thisCtxt, this, m), \
							methodActivationScope(m, bc), \
							methodNow=alsoMethodNow.
							
	executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, bc, retNowCtx, retNow) :-\
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, callBC, callNowCtxt, callNow), \
							invocationEdge(callNowCtxt, callNow, thisCtxt, this, callerM, callBC, receiverCtxt, receiver, calledM), \							
							returnActivationScope(callerM, bc, callBC), \
							methodReturn(calledM, retBC, _), \
							executionContext(callNowCtxt, callNow, receiverCtxt, receiver, calledM, retBC, retNowCtxt, retNow).
	
	#**********************
	#new statements
	#**********************
	# do not collapse the new objects for multiple callers (use alsoMethodNow instead of bcNow)
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v, alsoMethodNow, obj)	:- 	\
							new(bc, v, obj), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, _, _), \
							methodNow=alsoMethodNow.
	
	#**********************
	#schedule statement
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v, bcNow, obj) :- \
							schedule(bc, v, obj, _, _), \							
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, _, bcNow).
	
	#**********************
	#now statement
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v, bcNowCtxt, bcNow) :- \
							now(bc, v), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, bcNowCtxt, bcNow).
	
	#**********************
	#assignments; phi nodes and casts; could remove executionContext-clause?
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v1, actCtxt, obj)	:- \
							assign(bc, v1, v2), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, _, _), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v2, actCtxt, obj), \
							canPointTo(m, v1, obj).
	
	xxx todo: handle constants, staticStore, staticLoad, staticPrimLoad, staticPrimStore
	xxx: todo: make bytecodes be integers because SSAInstructions are different per method so the bytecode domain is over-full
	xxx hm, integers don't work just so. either i add the method do all the statement relations or i have to use bc objects
	that are equal when the bytecode "looks the same"
	
	#**********************
	#loads; could remove executionContext-clause?
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v2, actCtxt, obj2):- \
							load(bc, v2, v1, f), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, _, _), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v1, someActCtxt, obj1), \
							heapPT(someActCtxt, obj1, f, actCtxt, obj2), \
							canPointTo(m, v2, obj2).
	
	#**********************
	#stores; could remove executionContext-clause?
	#**********************
	heapPT(actCtxt1, obj1, f, actCtxt2, obj2):- \
							store(bc, v1, f, v2), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, m, bc, _, _), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v1, actCtxt1, obj1), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, m, v2, actCtxt2, obj2).
	
	#**********************
	#static calls
	#**********************
	#statically bound instance methods
	invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, callerM, invokeBC, receiverCtxt, receiver, calledM) :- \
							staticInstanceInvoke(invokeBC, calledM), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, invokeBC, bcNowCtxt, bcNow), \
							actual(callerM, invokeBC, 0, recVar), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, callerM, recVar, receiverCtxt, receiver).
	
	#statically bound class methods (doesn't use actual 0 variable but the global object)
	invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, callerM, invokeBC, 0, 0, calledM) :- \
							staticInvoke(invokeBC, calledM), \
							executionContext(_, _, thisCtxt, this, callerM, invokeBC, bcNowCtxt, bcNow).
																													
	#**********************
	#virtual calls
	#**********************
	invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, callerM, invokeBC, receiverCtxt, receiver, calledM) :- \
							virtualInvoke(invokeBC, selector), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, invokeBC, bcNowCtxt, bcNow), \
							actual(callerM, invokeBC, 0, recVar), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, callerM, recVar, receiverCtxt, receiver), \
							objectType(receiver, t), \
							member(t, selector, calledM).

	#**********************
	#parameter passing
	#**********************
	variablePT(bcNowCtxt, bcNow, receiverCtxt, receiver, calledM, formalVar, objCtxt, obj) :- \
							formal(calledM, z, formalVar), \															
							invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, callerM, invokeBC, receiverCtxt, receiver, calledM), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, invokeBC, bcNowCtxt, bcNow), \
							actual(callerM, invokeBC, z, actualVar), \
							variablePT(methodNowCtxt, methodNow, thisCtxt, this, callerM, actualVar, objCtxt, obj).
						
	#**********************	
	#returns and exceptions
	#**********************
	variablePT(methodNowCtxt, methodNow, thisCtxt, this, callerM, callerRetVar, objCtxt, obj) :- \
							callSiteReturn(callerM, invokeBC, callerRetVar), \
							executionContext(methodNowCtxt, methodNow, thisCtxt, this, callerM, invokeBC, bcNowCtxt, bcNow), \
							invocationEdge(bcNowCtxt, bcNow, thisCtxt, this, callerM, invokeBC, receiverCtxt, receiver, calledM),  \
							methodReturn(calledM, _, retVar), \
							variablePT(bcNowCtxt, bcNow, receiverCtxt, receiver, calledM, retVar, objCtxt, obj), \
							canPointTo(callerM, callerRetVar, obj).
	