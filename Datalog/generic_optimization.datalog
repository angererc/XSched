.basedir "../analysis.out"

### Domains
.include "Object.dom"
.include "Variable.dom"
.include "Field.dom"
.include "Method.dom"

#9.802
#.bddvarorder Method0_Method1_Variable0_Variable1_Object0_Object1_Object2_Object3_Object4_Object6_Object7_Object8_Field0_Field1_Object9_Object5

#statements     		                                                            
new						(m:Method, dest:Variable, obj:Object)					input
constant				(m:Method, variable:Variable, object:Object)			input
load					(m:Method, variable:Variable, base:Variable, field:Field)	input
primLoad				(m:Method, base:Variable, field:Field)					input
staticLoad				(m:Method, dest:Variable, field:Field) 					input
staticPrimLoad			(m:Method, field:Field) 								input
store					(m:Method, base:Variable, field:Field, source:Variable) input
primStore				(m:Method, base:Variable, field:Field) 					input
staticStore				(m:Method, field:Field, source:Variable) 				input	
staticPrimStore			(m:Method, field:Field) 								input	

executionContext		(nowCtxt:Object, now:Object, \
							 thisCtxt:Object, this:Object, \
							 m:Method)											input

variablePT				(nowCtxt:Object, now:Object, \
						 thisCtxt:Object, this:Object, \
						 method:Method, variable:Variable, \
						 actContext:Object, object:Object)						input						

#what statements in a method count as access
access(method:Method, variable:Variable)
access(m, v) :- new(m, v, _).
#access(m, v) :- constant(m, v, _).
access(m, v) :- load(m, _, v, _).
access(m, v) :- primLoad(m, v, _).
access(m, v) :- store(m, v, _, _).
access(m, v) :- primStore(m, v, _).

accessStatic(method:Method, field:Field)
accessStatic(m, f) :- staticLoad(m,_, f).
accessStatic(m, f) :- staticPrimLoad(m, f).
accessStatic(m, f) :- staticStore(m, f, _).
accessStatic(m, f) :- staticPrimStore(m, f).	

accessesMayInterfere(m1:Method, v1:Variable, m2:Method, v2:Variable) outputtuples printsize
staticAccessesMayInterfere(m1:Method, field1:Field, m2:Method, field2:Field) outputtuples printsize

accessMayInterfereByMethod(m1:Method) outputtuples
accessMayInterfereByMethod(m1) :- accessesMayInterfere(m1, _, _, _).
accessMayInterfereByMethod(m2) :- accessesMayInterfere(_, _, m2, _).


#in accessMayInterfere(m1, v1, m2, v2) then also accessMayInterfere(m2, v2, m1, v1). Therefore it contains many duplicate entries
#use this to get to the real number of accessMayInterfere:
# ((num accessMayInterfere - num selfAccessMayInterfere)/2) + num selfAccessMayInterfere = num unique
selfAccessMayInterfere(m1:Method, v1:Variable, m2:Method, v2:Variable) printsize
selfAccessMayInterfere(m1, v1, m2, v2) :- accessesMayInterfere(m1, v1, m2, v2), m1=m2, v1=v2.

#SIZE OF accessesMayInterfere: 242946.
#SIZE OF staticAccessesMayInterfere: 444.
.include "./generic_optimization.p2_only"

#SIZE OF accessesMayInterfere: 6690.
#SIZE OF staticAccessesMayInterfere: 186.
#.include "./generic_optimization.p2_escape"

#SIZE OF accessesMayInterfere: 61303.
#SIZE OF staticAccessesMayInterfere: 54.
#.include "./generic_optimization.p2_sa"

#SIZE OF accessesMayInterfere: 1.
#SIZE OF staticAccessesMayInterfere: 54.
#.include "./generic_optimization.p2_escape_sa"

