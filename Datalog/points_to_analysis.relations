### Relations
	roots					(method:Method)											input				
	                		                                                            
	#statements     		                                                            
	new						(m:Method, dest:Variable, obj:Object)					input
	schedule				(m:Method, bc:BC, dest:Variable, obj:Object, name:Selector)	input
	now						(m:Method, variable:Variable)							input
	constant				(m:Method, variable:Variable, object:Object)			input
	load					(m:Method, variable:Variable, base:Variable, field:Field)	input
#	primLoad				(m:Method, base:Variable, field:Field)					input
	staticLoad				(m:Method, dest:Variable, field:Field) 					input
#	staticPrimLoad			(m:Method, field:Field) 								input
	store					(m:Method, base:Variable, field:Field, source:Variable) input
#	primStore				(m:Method, base:Variable, field:Field) 					input
	staticStore				(m:Method, field:Field, source:Variable) 				input	
#	staticPrimStore			(m:Method, field:Field) 								input	
	assign					(m:Method, dest:Variable, source:Variable)				input
	#arrow					(m:Method, lhs:Variable, rhs:Variable)					input
	methodReturn			(m:Method, var:Variable)								input
	methodThrow				(m:Method, var:Variable)								input
	 		                                                            
	#types          		                                                            
	variableType			(method:Method, variable:Variable, type:Type)			input
	objectType				(object:Object, type:Type)								input
	#NOTE: assignable must be a flattened hierarchy already, including same-type 
	assignable				(supertype:Type, subtype:Type)							input
	member					(type:Type, name:Selector, target:Method)				input
		                                                                                   
	#control flow                                                                       
	actual					(method:Method, invokeBC:BC, param:ParamPosition, var:Variable)	input
	formal					(method:Method, param:ParamPosition, var:Variable)		input
				                                                                                    
	#call sites                                                                         
	staticClassInvoke		(m:Method, invokeBC:BC, target:Method)					input
	staticInstanceInvoke	(m:Method, invokeBC:BC, target:Method)					input
	virtualInvoke			(m:Method, invokeBC:BC, name:Selector) 					input
	callSiteReturn			(m:Method, invokeBC:BC, var:Variable)					input
	#we catch all exceptions by type that can be assigned to var; that's hopefully precise enough for what we want to do
	catch					(m:Method, var:Variable)								input
	
	
	canPointTo				(method:Method, variable:Variable, object:Object)
	
	variablePT				(nowCtxt:Object, now:Object, \
							 thisCtxt:Object, this:Object, \
							 method:Method, variable:Variable, \
							 actContext:Object, object:Object)						output outputtuples
							
	heapPT					(baseCtxt:Object, base:Object, \
							 field:Field, \
							 targetCtxt:Object, target:Object)						output outputtuples
	
	#method m on thisCtxt.this is executed in nowCtxt.now;
	#the execution context is just a projection of the invocationEdge relation to simplify some things
	executionContext		(nowCtxt:Object, now:Object, \
							 thisCtxt:Object, this:Object, \
							 m:Method)												output

	#in method callerMethod of callerThisCtxt.callerThis executed in callerNowCtxt.callerNow, 
	#bytecode invokeBC is a call to 
	#method receiverCtxt.receiver.target executed in receiverNowCtxt,receiverNow
	invocationEdge			(callerNowCtxt:Object, callerNow:Object, \
							 callerThisCtxt:Object, callerThis:Object, \
							 callerMethod:Method, invokeBC:BC, \
							 calledNowCtxt:Object, calledNow:Object, \
							 caledThisCtxt:Object, calledThis:Object, calledMethod:Method)	output outputtuples