
#************************************
# ordered-ness of activations
#************************************

#there can be activations that are only ordered (in ordered0) but not orderedBefore. mix those into the ordered relation
ordered(nowCtxt:Object, now:Object, a:A0, b:A1) 
ordered(nowCtxt, now, a, alsoA) :- ordered0(nowCtxt, now, a), a=alsoA.
ordered(nowCtxt, now, a, b) :- orderedBefore(nowCtxt, now, a, b).
ordered(nowCtxt, now, a, b) :- orderedBefore(nowCtxt, now, b, a).
ordered(nowCtxt, now, a, b) :- ordered(nowCtxt, now, b, a).

#************************************
# infos about parameter flows
#************************************

#in nowCtxt.now, actual is a direct parameter to a and mapped to formal in a's task resNowCtxt.resNow
param(nowCtxt:Object, now:Object, a:A0, actual:A1, resNowCtxt:Object, resNow:Object, formal:A2)
param(nowCtxt, now, a, actual, resNowCtxt, resNow, formal) :- \
		actual0(nowCtxt, now, a, n, actual), \
		schedules0(nowCtxt, now, a, resNowCtxt, resNow), \
		formal0(resNowCtxt, resNow, n, formal).

#used in negations, where you cannot really use _ (bug in bddbddb? or some concept I don't understand?)
isParam(nowCtxt:Object, now:Object, a:A0, param:A1)
isParam(nowCtxt, now, a, actual) :- param(nowCtxt, now, a, actual, _, _, _).

#in t, b is the parameter or ordered after the parameter that is mapped to formal in ta
paramOrAfter(nowCtxt:Object, now:Object, a:A0, b:A1, resNowCtxt:Object, resNow:Object, formal:A2)
paramOrAfter(nowCtxt, now, a, actual, resNowCtxt, resNow, formal) :- \
		param(nowCtxt, now, a, actual, resNowCtxt, resNow, formal).
paramOrAfter(nowCtxt, now, a, after, resNowCtxt, resNow, formal) :- \
		param(nowCtxt, now, a, actual, resNowCtxt, resNow, formal), \
		orderedBefore(nowCtxt, now, actual, after).

isParamOrAfter(nowCtxt:Object, now:Object, a:A0, b:A1)
isParamOrAfter(nowCtxt, now, a, b) :- paramOrAfter(nowCtxt, now, a, b, _, _, _).

paramOrBefore(nowCtxt:Object, now:Object, a:A0, b:A1, resNowCtxt:Object, resNow:Object, formal:A2)
paramOrBefore(nowCtxt, now, a, actual, resNowCtxt, resNow, formal) :- \
		param(nowCtxt, now, a, actual, resNowCtxt, resNow, formal).
paramOrBefore(nowCtxt, now, a, before, resNowCtxt, resNow, formal) :- \
		param(nowCtxt, now, a, actual, resNowCtxt, resNow, formal), \
		orderedBefore(nowCtxt, now, before, actual).

isParamOrBefore(nowCtxt:Object, now:Object, a:A0, b:A1)
isParamOrBefore(nowCtxt, now, a, b) :- paramOrBefore(nowCtxt, now, a, b, _, _, _).

#************************************
# tasks not ordered computation
#************************************

children(nowCtxt:Object, now:Object, resNowCtxt:Object, resNow:Object)
children(nowCtxt, now, resNowCtxt, resNow) :- \
		schedules0(nowCtxt, now, _, resNowCtxt, resNow).
children(nowCtxt, now, resNowCtxt2, resNow2) :- \
		children(nowCtxt, now, resNowCtxt1, resNow1), \
		children(resNowCtxt1, resNow1, resNowCtxt2, resNow2).

contains(nowCtxt:Object, now:Object, a:A0, b:A1)
contains(nowCtxt, now, a, b) :- schedules0(nowCtxt, now, a, _, _), schedules0(nowCtxt, now, b, _, _).
contains(nowCtxt, now, a, b) :- formal0(nowCtxt, now, _, a), formal0(nowCtxt, now, _, b).
contains(nowCtxt, now, a, b) :- schedules0(nowCtxt, now, a, _, _), formal0(nowCtxt, now, _, b).
contains(nowCtxt, now, a, b) :- contains(nowCtxt, now, b, a).

tasksNotOrderedBefore(nowCtxt:Object, now:Object, b:A0, resNowCtxt:Object, resNow:Object)
tasksNotOrderedBefore(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!orderedBefore(nowCtxt, now, a, b), \
			schedules0(nowCtxt, now, a, resNowCtxt, resNow).
tasksNotOrderedBefore(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			paramOrAfter(nowCtxt, now, a, b, nCA, nA, formal), \
			tasksNotOrderedBefore(nCA, nA, formal, resNowCtxt, resNow).
tasksNotOrderedBefore(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!isParamOrAfter(nowCtxt, now, a, b), \
			schedules0(nowCtxt, now, a, nCA, nA), \
			children(nCA, nA, resNowCtxt, resNow).
#i think that the following clause isn't really needed. we only recurse into tasks ot ordered before with formals and those don't have any children			
tasksNotOrderedBefore(nowCtxt, now, b, resNowCtxt, resNow) :- \
			schedules0(nowCtxt, now, b, nCB, nB), \
			children(nCB, nB, resNowCtxt, resNow).

tasksNotOrderedAfter(nowCtxt:Object, now:Object, b:A0, resNowCtxt:Object, resNow:Object)
tasksNotOrderedAfter(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!orderedBefore(nowCtxt, now, b, a), \
			schedules0(nowCtxt, now, a, resNowCtxt, resNow).
tasksNotOrderedAfter(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			paramOrBefore(nowCtxt, now, a, b, nCA, nA, formal), \
			tasksNotOrderedAfter(nCA, nA, formal, resNowCtxt, resNow).
tasksNotOrderedAfter(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!isParamOrBefore(nowCtxt, now, a, b), \
			!orderedBefore(nowCtxt, now, b, a), \
			schedules0(nowCtxt, now, a, nCA, nA), \
			children(nCA, nA, resNowCtxt, resNow).

tasksNotOrdered(nowCtxt:Object, now:Object, b:A0, resNowCtxt:Object, resNow:Object)
tasksNotOrdered(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!ordered(nowCtxt, now, a, b), \
			schedules0(nowCtxt, now, a, resNowCtxt, resNow).
tasksNotOrdered(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			param(nowCtxt, now, a, b, nCA, nA, formal), \
			tasksNotOrdered(nCA, nA, formal, resNowCtxt, resNow).
tasksNotOrdered(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!isParam(nowCtxt, now, a, b), \
			paramOrAfter(nowCtxt, now, a, b, nCA, nA, formal), \
			tasksNotOrderedBefore(nCA, nA, formal, resNowCtxt, resNow).
tasksNotOrdered(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!isParam(nowCtxt, now, a, b), \
			paramOrBefore(nowCtxt, now, a, b, nCA, nA, formal), \
			tasksNotOrderedAfter(nCA, nA, formal, resNowCtxt, resNow).
tasksNotOrdered(nowCtxt, now, b, resNowCtxt, resNow) :- \
			contains(nowCtxt, now, a, b), \
			!singleton(nowCtxt, now, a, b), \
			!isParam(nowCtxt, now, a, b), \
			!isParamOrAfter(nowCtxt, now, a, b), \
			!isParamOrBefore(nowCtxt, now, a, b), \
			!orderedBefore(nowCtxt, now, b, a), \
			schedules0(nowCtxt, now, a, nCA, nA), \
			children(nCA, nA, resNowCtxt, resNow).

##
parallel(nowCtxt1, now1, nowCtxt2, now2) :-	\
			schedules0(nC1, n1, a, nowCtxt1, now1), \
			tasksNotOrdered(nC1, n1, a, nowCtxt2, now2).
#the next clause could be made a little more precise, no?
#if b is a param to a then b's children are parallel only to all children of a that are not ordered before
parallel(nowCtxt1, now1, nowCtxt2, now2) :-	\
			contains(nC1, n1, a, b), \
			!singleton(nC1, n1, a, b), \
			schedules0(nC1, n1, a, nCA, nA), \
			schedules0(nC1, n1, b, nCB, nB), \
			children(nCA, nA, nowCtxt1, now1), \
			children(nCB, nB, nowCtxt2, now2).
parallel(nowCtxt1, now1, nowCtxt2, now2) :- \
			parallel(nowCtxt2, now2, nowCtxt1, now1).